(1.)
    def compute_scattering(self, rGen_ray, scene, maxDepth):

        if maxDepth <= 0:
            return rtu.Color()

        # if the generated ray hits an object
        found_hit = scene.find_intersection(rGen_ray, rtu.Interval(0.000001, rtu.infinity_number))
        if found_hit == True:
            # get the hit info
            hinfo = scene.getHitList()
            # get the material of the object
            hmat = hinfo.getMaterial()
            # compute scattering
            sinfo = hmat.scattering(rGen_ray, hinfo)
            # if no scattering (It is a light source)
            if sinfo is None:
                # return Le
                return hmat.emitting()


            # Class assignemnt (1.)
            Le = rtu.Color()
            # if direct lighting is enabled
            if self.bool_direct_lighting:
                # for each point light
                for light in scene.point_light_list:
                    # check if there is an occlusion between a point light and a surface point.
                    tolight_dir = light.center - hinfo.getP()
                    tolight_ray = rtr.Ray(hinfo.getP(), tolight_dir)
                    max_distance = tolight_dir.len()
                    occlusion_hit = scene.find_occlusion(tolight_ray, rtu.Interval(0.000001, max_distance))
                    # if not occluded.
                    if not occlusion_hit:
                        # accumulate all unoccluded light
                        Le = Le + (light.material.emitting() * (1/max_distance))

            # return the color
            return Le + self.compute_scattering(rtr.Ray(hinfo.getP(), sinfo.scattered_ray.getDirection()), scene, maxDepth-1) * sinfo.attenuation_color

        return scene.getBackgroundColor()

(2.)
def renderPointLight():

    main_camera = rtc.Camera()
    main_camera.aspect_ratio = 1.0
    main_camera.img_width = 400
    main_camera.center = rtu.Vec3(0,0,0)
    main_camera.samples_per_pixel = 10
    main_camera.max_depth = 4
    main_camera.vertical_fov = 90
    main_camera.look_from = rtu.Vec3(0, 0, 10)
    main_camera.look_at = rtu.Vec3(0, 0, 0)
    main_camera.vec_up = rtu.Vec3(0, 1, 0)

    defocus_angle = 0.0
    focus_distance = 3.0
    main_camera.init_camera(defocus_angle, focus_distance)
    # add objects to the scene

    left_red = rtm.Lambertian(    rtu.Color(1.0, 0.2, 0.2))
    back_green = rtm.Lambertian(  rtu.Color(0.2, 1.0, 0.2))
    right_blue = rtm.Lambertian(  rtu.Color(0.2, 0.2, 1.0))
    upper_orange = rtm.Lambertian(rtu.Color(1.0, 0.5, 0.0))
    lower_teal = rtm.Lambertian(  rtu.Color(0.2, 0.8, 0.8))
    
    point_light = rtl.Diffuse_light(rtu.Color(1.0, 1.0, 1.0))

    world = rts.Scene()
    world.add_object(rto.Quad(rtu.Vec3(-3,-2, 5), rtu.Vec3(0, 0,-4), rtu.Vec3(0, 4, 0), left_red))
    world.add_object(rto.Quad(rtu.Vec3(-2,-2, 0), rtu.Vec3(4, 0, 0), rtu.Vec3(0, 4, 0), back_green))
    world.add_object(rto.Quad(rtu.Vec3( 3,-2, 1), rtu.Vec3(0, 0, 4), rtu.Vec3(0, 4, 0), right_blue))
    world.add_object(rto.Quad(rtu.Vec3(-2, 3, 1), rtu.Vec3(4, 0, 0), rtu.Vec3(0, 0, 4), upper_orange))
    world.add_object(rto.Quad(rtu.Vec3(-2,-3, 5), rtu.Vec3(4, 0, 0), rtu.Vec3(0, 0,-4), lower_teal))

    world.add_object(rto.Sphere(rtu.Vec3(0, 0, 0), 0.1, point_light))

    intg = rti.Integrator()

    renderer = rtren.Renderer(main_camera, intg, world)
    renderer.render()
    renderer.write_img2png('week05_point_light.png')    

(5.)
def renderPointLightShadow():

    main_camera = rtc.Camera()
    main_camera.aspect_ratio = 1.0
    main_camera.img_width = 400
    main_camera.center = rtu.Vec3(0,0,0)
    main_camera.samples_per_pixel = 10
    main_camera.max_depth = 4
    main_camera.vertical_fov = 90
    main_camera.look_from = rtu.Vec3(0, 0, 10)
    main_camera.look_at = rtu.Vec3(0, 0, 0)
    main_camera.vec_up = rtu.Vec3(0, 1, 0)

    defocus_angle = 0.0
    focus_distance = 3.0
    main_camera.init_camera(defocus_angle, focus_distance)
    # add objects to the scene

    left_red = rtm.Lambertian(    rtu.Color(1.0, 0.2, 0.2))
    back_green = rtm.Lambertian(  rtu.Color(0.2, 1.0, 0.2))
    right_blue = rtm.Lambertian(  rtu.Color(0.2, 0.2, 1.0))
    upper_orange = rtm.Lambertian(rtu.Color(1.0, 0.5, 0.0))
    lower_teal = rtm.Lambertian(  rtu.Color(0.2, 0.8, 0.8))

    point_light = rtl.Diffuse_light(rtu.Color(1.0, 1.0, 1.0))

    world = rts.Scene()
    world.add_object(rto.Quad(rtu.Vec3(-3,-2, 5), rtu.Vec3(0, 0,-4), rtu.Vec3(0, 4, 0), left_red))
    world.add_object(rto.Quad(rtu.Vec3(-2,-2, 0), rtu.Vec3(4, 0, 0), rtu.Vec3(0, 4, 0), back_green))
    world.add_object(rto.Quad(rtu.Vec3( 3,-2, 1), rtu.Vec3(0, 0, 4), rtu.Vec3(0, 4, 0), right_blue))
    world.add_object(rto.Quad(rtu.Vec3(-2, 3, 1), rtu.Vec3(4, 0, 0), rtu.Vec3(0, 0, 4), upper_orange))
    world.add_object(rto.Quad(rtu.Vec3(-2,-3, 5), rtu.Vec3(4, 0, 0), rtu.Vec3(0, 0,-4), lower_teal))

    world.add_object(rto.Sphere(rtu.Vec3(4, 0, 0), 0.1, point_light))

    intg = rti.Integrator()

    renderer = rtren.Renderer(main_camera, intg, world)
    renderer.render()
    renderer.write_img2png('week05_point_light_shadow.png')    
    