(1.) Implement 'intersect()' method of the Sphere class.
    def intersect(self, rRay, cInterval):
        
        # find roots of the quadratic solution.
        if tmin < 0:
            return None
        
        oc = rRay.getOrigin() - self.center
        a = rRay.getDirection().len_squared()
        half_b = rtu.Vec3.dot_product(oc, rRay.getDirection())
        c = oc.len_squared() - self.radius*self.radius
        discriminant = half_b*half_b - a*c 

        if discriminant < 0:
            return None
        sqrt_disc = math.sqrt(discriminant)
        root = (-half_b - sqrt_disc) / a 

        # check if the positive root is in the interval
        if root <= tmin or root >= tmax:
            root = (-half_b + sqrt_disc) / a 
            if root <= tmin or root >= tmax:
                return None
            
        # generate and return a hit info
        hit_t = root
        hit_point = rRay.at(root)
        hit_normal = (hit_point - self.center) / self.radius
        hinfo = rtu.Hitinfo(hit_point, hit_normal, hit_t, self.material)
        hinfo.set_face_normal(rRay, hit_normal) 
        return hinfo

(2.) Implement calculations of the quad parameters.
    self.uxv = rtu.Vec3.cross_product(self.Uvec, self.Vvec)
    self.normal = rtu.Vec3.unit_vector(self.uxv)
    self.D = rtu.Vec3.dot_product(self.normal, self.Qpoint)
    self.Wvec = self.uxv / rtu.Vec3.dot_product(self.uxv, self.uxv)

(3.) Implement 'intersect()' method of the Quad class.
    def intersect(self, rRay, cInterval):

        denom = rtu.Vec3.dot_product(self.normal, rRay.getDirection())
        # if parallel
        if rtu.Interval.near_zero(denom):
            return None

        # if the ray hits the plane.
        t = (self.D - rtu.Vec3.dot_product(self.normal, rRay.getOrigin())) / denom
        if not cInterval.contains(t):
            return None
        
        hit_t = t
        hit_point = rRay.at(t)
        hit_normal = self.normal

        # determine if the intersection point lies on the quad's plane.
        planar_hit = hit_point - self.Qpoint
        alpha = rtu.Vec3.dot_product(self.Wvec, rtu.Vec3.cross_product(planar_hit, self.Vvec))
        beta = rtu.Vec3.dot_product(self.Wvec, rtu.Vec3.cross_product(self.Uvec, planar_hit))
        if self.is_interior(alpha, beta) is None:
            return None

        # generate and return a hit info
        hinfo = rtu.Hitinfo(hit_point, hit_normal, hit_t, self.material)
        hinfo.set_face_normal(rRay, hit_normal)
        return hinfo

